/*
 * Voucherify API
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package voucherify.client.api;

import voucherify.client.ApiCallback;
import voucherify.client.ApiClient;
import voucherify.client.ApiException;
import voucherify.client.ApiResponse;
import voucherify.client.Configuration;
import voucherify.client.Pair;
import voucherify.client.ProgressRequestBody;
import voucherify.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.io.File;
import java.time.OffsetDateTime;
import voucherify.client.model.ParameterOrder;
import voucherify.client.model.ProductsCreateRequestBody;
import voucherify.client.model.ProductsCreateResponseBody;
import voucherify.client.model.ProductsGetResponseBody;
import voucherify.client.model.ProductsImportCsvCreateResponseBody;
import voucherify.client.model.ProductsListResponseBody;
import voucherify.client.model.ProductsMetadataUpdateInBulkRequestBody;
import voucherify.client.model.ProductsMetadataUpdateInBulkResponseBody;
import voucherify.client.model.ProductsSkusCreateRequestBody;
import voucherify.client.model.ProductsSkusCreateResponseBody;
import voucherify.client.model.ProductsSkusListResponseBody;
import voucherify.client.model.ProductsSkusUpdateRequestBody;
import voucherify.client.model.ProductsSkusUpdateResponseBody;
import voucherify.client.model.ProductsUpdateInBulkRequestBody;
import voucherify.client.model.ProductsUpdateInBulkResponseBody;
import voucherify.client.model.ProductsUpdateRequestBody;
import voucherify.client.model.ProductsUpdateResponseBody;
import voucherify.client.model.SkusGetResponseBody;
import voucherify.client.model.SkusImportCsvCreateResponseBody;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ProductsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ProductsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ProductsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createProduct
     * @param productsCreateRequestBody Specify the product parameters. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if the operation succeeded. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createProductCall(ProductsCreateRequestBody productsCreateRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = productsCreateRequestBody;

        // create path and map variables
        String localVarPath = "/v1/products";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createProductValidateBeforeCall(ProductsCreateRequestBody productsCreateRequestBody, final ApiCallback _callback) throws ApiException {
        return createProductCall(productsCreateRequestBody, _callback);

    }

    /**
     * Create Product
     * Creates a product object.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the product database, Voucherify will return a related product object with updated fields.
     * @param productsCreateRequestBody Specify the product parameters. (optional)
     * @return ProductsCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if the operation succeeded. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsCreateResponseBody createProduct(ProductsCreateRequestBody productsCreateRequestBody) throws ApiException {
        ApiResponse<ProductsCreateResponseBody> localVarResp = createProductWithHttpInfo(productsCreateRequestBody);
        return localVarResp.getData();
    }

    /**
     * Create Product
     * Creates a product object.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the product database, Voucherify will return a related product object with updated fields.
     * @param productsCreateRequestBody Specify the product parameters. (optional)
     * @return ApiResponse&lt;ProductsCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if the operation succeeded. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsCreateResponseBody> createProductWithHttpInfo(ProductsCreateRequestBody productsCreateRequestBody) throws ApiException {
        okhttp3.Call localVarCall = createProductValidateBeforeCall(productsCreateRequestBody, null);
        Type localVarReturnType = new TypeToken<ProductsCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Product (asynchronously)
     * Creates a product object.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the product database, Voucherify will return a related product object with updated fields.
     * @param productsCreateRequestBody Specify the product parameters. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if the operation succeeded. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createProductAsync(ProductsCreateRequestBody productsCreateRequestBody, final ApiCallback<ProductsCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = createProductValidateBeforeCall(productsCreateRequestBody, _callback);
        Type localVarReturnType = new TypeToken<ProductsCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createSku
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param productsSkusCreateRequestBody Specify the SKU parameters to be created. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSkuCall(String productId, ProductsSkusCreateRequestBody productsSkusCreateRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = productsSkusCreateRequestBody;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}/skus"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSkuValidateBeforeCall(String productId, ProductsSkusCreateRequestBody productsSkusCreateRequestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling createSku(Async)");
        }

        return createSkuCall(productId, productsSkusCreateRequestBody, _callback);

    }

    /**
     * Create SKU
     * This method adds product variants to a &lt;!-- [created product](OpenAPI.json/paths/~1products/post) --&gt;[created product](ref:create-product).   &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the sku database, Voucherify will return a related sku object with updated fields.
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param productsSkusCreateRequestBody Specify the SKU parameters to be created. (optional)
     * @return ProductsSkusCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsSkusCreateResponseBody createSku(String productId, ProductsSkusCreateRequestBody productsSkusCreateRequestBody) throws ApiException {
        ApiResponse<ProductsSkusCreateResponseBody> localVarResp = createSkuWithHttpInfo(productId, productsSkusCreateRequestBody);
        return localVarResp.getData();
    }

    /**
     * Create SKU
     * This method adds product variants to a &lt;!-- [created product](OpenAPI.json/paths/~1products/post) --&gt;[created product](ref:create-product).   &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the sku database, Voucherify will return a related sku object with updated fields.
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param productsSkusCreateRequestBody Specify the SKU parameters to be created. (optional)
     * @return ApiResponse&lt;ProductsSkusCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsSkusCreateResponseBody> createSkuWithHttpInfo(String productId, ProductsSkusCreateRequestBody productsSkusCreateRequestBody) throws ApiException {
        okhttp3.Call localVarCall = createSkuValidateBeforeCall(productId, productsSkusCreateRequestBody, null);
        Type localVarReturnType = new TypeToken<ProductsSkusCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create SKU (asynchronously)
     * This method adds product variants to a &lt;!-- [created product](OpenAPI.json/paths/~1products/post) --&gt;[created product](ref:create-product).   &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the sku database, Voucherify will return a related sku object with updated fields.
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param productsSkusCreateRequestBody Specify the SKU parameters to be created. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the created SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSkuAsync(String productId, ProductsSkusCreateRequestBody productsSkusCreateRequestBody, final ApiCallback<ProductsSkusCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = createSkuValidateBeforeCall(productId, productsSkusCreateRequestBody, _callback);
        Type localVarReturnType = new TypeToken<ProductsSkusCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteProduct
     * @param productId A Voucherify product ID or source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the product and all related SKUs will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same &#x60;source_id&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteProductCall(String productId, Boolean force, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("force", force));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteProductValidateBeforeCall(String productId, Boolean force, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling deleteProduct(Async)");
        }

        return deleteProductCall(productId, force, _callback);

    }

    /**
     * Delete Product
     * Deletes a product and all related SKUs. This operation cannot be undone.   If the &#x60;force&#x60; parameter is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to [the bin](ref:list-bin-entries).
     * @param productId A Voucherify product ID or source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the product and all related SKUs will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same &#x60;source_id&#x60;. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteProduct(String productId, Boolean force) throws ApiException {
        deleteProductWithHttpInfo(productId, force);
    }

    /**
     * Delete Product
     * Deletes a product and all related SKUs. This operation cannot be undone.   If the &#x60;force&#x60; parameter is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to [the bin](ref:list-bin-entries).
     * @param productId A Voucherify product ID or source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the product and all related SKUs will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same &#x60;source_id&#x60;. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteProductWithHttpInfo(String productId, Boolean force) throws ApiException {
        okhttp3.Call localVarCall = deleteProductValidateBeforeCall(productId, force, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Product (asynchronously)
     * Deletes a product and all related SKUs. This operation cannot be undone.   If the &#x60;force&#x60; parameter is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to [the bin](ref:list-bin-entries).
     * @param productId A Voucherify product ID or source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the product and all related SKUs will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same &#x60;source_id&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteProductAsync(String productId, Boolean force, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteProductValidateBeforeCall(productId, force, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteSku
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the SKU will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same &#x60;source_id&#x60;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSkuCall(String productId, String skuId, Boolean force, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}/skus/{skuId}"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()))
            .replace("{" + "skuId" + "}", localVarApiClient.escapeString(skuId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (force != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("force", force));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSkuValidateBeforeCall(String productId, String skuId, Boolean force, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling deleteSku(Async)");
        }

        // verify the required parameter 'skuId' is set
        if (skuId == null) {
            throw new ApiException("Missing the required parameter 'skuId' when calling deleteSku(Async)");
        }

        return deleteSkuCall(productId, skuId, force, _callback);

    }

    /**
     * Delete SKU
     * Deletes a product SKU. This operation cannot be undone.   If the &#x60;force&#x60; parameter is set to &#x60;false&#x60; or not set at all, the SKU will be moved to [the bin](ref:list-bin-entries).
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the SKU will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same &#x60;source_id&#x60;. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteSku(String productId, String skuId, Boolean force) throws ApiException {
        deleteSkuWithHttpInfo(productId, skuId, force);
    }

    /**
     * Delete SKU
     * Deletes a product SKU. This operation cannot be undone.   If the &#x60;force&#x60; parameter is set to &#x60;false&#x60; or not set at all, the SKU will be moved to [the bin](ref:list-bin-entries).
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the SKU will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same &#x60;source_id&#x60;. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteSkuWithHttpInfo(String productId, String skuId, Boolean force) throws ApiException {
        okhttp3.Call localVarCall = deleteSkuValidateBeforeCall(productId, skuId, force, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete SKU (asynchronously)
     * Deletes a product SKU. This operation cannot be undone.   If the &#x60;force&#x60; parameter is set to &#x60;false&#x60; or not set at all, the SKU will be moved to [the bin](ref:list-bin-entries).
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param force If this flag is set to &#x60;true&#x60;, the SKU will be removed permanently. If it is set to &#x60;false&#x60; or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same &#x60;source_id&#x60;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSkuAsync(String productId, String skuId, Boolean force, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSkuValidateBeforeCall(productId, skuId, force, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getProduct
     * @param productId A Voucherify product ID or source ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getProductCall(String productId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getProductValidateBeforeCall(String productId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling getProduct(Async)");
        }

        return getProductCall(productId, _callback);

    }

    /**
     * Get Product
     * Retrieve product details.
     * @param productId A Voucherify product ID or source ID. (required)
     * @return ProductsGetResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsGetResponseBody getProduct(String productId) throws ApiException {
        ApiResponse<ProductsGetResponseBody> localVarResp = getProductWithHttpInfo(productId);
        return localVarResp.getData();
    }

    /**
     * Get Product
     * Retrieve product details.
     * @param productId A Voucherify product ID or source ID. (required)
     * @return ApiResponse&lt;ProductsGetResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsGetResponseBody> getProductWithHttpInfo(String productId) throws ApiException {
        okhttp3.Call localVarCall = getProductValidateBeforeCall(productId, null);
        Type localVarReturnType = new TypeToken<ProductsGetResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Product (asynchronously)
     * Retrieve product details.
     * @param productId A Voucherify product ID or source ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a product object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getProductAsync(String productId, final ApiCallback<ProductsGetResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = getProductValidateBeforeCall(productId, _callback);
        Type localVarReturnType = new TypeToken<ProductsGetResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSku
     * @param skuId A Voucherify SKU identifier or SKU source ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns requested SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSkuCall(String skuId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/skus/{skuId}"
            .replace("{" + "skuId" + "}", localVarApiClient.escapeString(skuId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSkuValidateBeforeCall(String skuId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'skuId' is set
        if (skuId == null) {
            throw new ApiException("Missing the required parameter 'skuId' when calling getSku(Async)");
        }

        return getSkuCall(skuId, _callback);

    }

    /**
     * Get SKU
     * Retrieve details of a SKU.
     * @param skuId A Voucherify SKU identifier or SKU source ID. (required)
     * @return SkusGetResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns requested SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public SkusGetResponseBody getSku(String skuId) throws ApiException {
        ApiResponse<SkusGetResponseBody> localVarResp = getSkuWithHttpInfo(skuId);
        return localVarResp.getData();
    }

    /**
     * Get SKU
     * Retrieve details of a SKU.
     * @param skuId A Voucherify SKU identifier or SKU source ID. (required)
     * @return ApiResponse&lt;SkusGetResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns requested SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SkusGetResponseBody> getSkuWithHttpInfo(String skuId) throws ApiException {
        okhttp3.Call localVarCall = getSkuValidateBeforeCall(skuId, null);
        Type localVarReturnType = new TypeToken<SkusGetResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get SKU (asynchronously)
     * Retrieve details of a SKU.
     * @param skuId A Voucherify SKU identifier or SKU source ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns requested SKU object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSkuAsync(String skuId, final ApiCallback<SkusGetResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSkuValidateBeforeCall(skuId, _callback);
        Type localVarReturnType = new TypeToken<SkusGetResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importProductsUsingCsv
     * @param _file File path. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and products will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call importProductsUsingCsvCall(File _file, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/products/importCSV";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importProductsUsingCsvValidateBeforeCall(File _file, final ApiCallback _callback) throws ApiException {
        return importProductsUsingCsvCall(_file, _callback);

    }

    /**
     * Import Products using CSV
     * Import products into the repository using a CSV file.    Curl Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/products/importCSV \\   -F file&#x3D;@/path/to/products.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60;  The CSV file has to include headers in the first line.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Standard product fields mapping &gt; &gt; - Create a **comma separated value (CSV) file** or download our CSV import template. You can find an example template [here](https://s3.amazonaws.com/helpscout.net/docs/assets/5902f1c12c7d3a057f88a36d/attachments/627b82ed68d51e779443f550/Import_products_template.csv). &gt; - Supported CSV file headers: &#x60;name,source_id,price,attributes,image_url,Metadata_property_name&#x60; &gt; - **Name** is a **required** field. The remaining fields in the CSV template are optional. &gt; - Override/Update products&#39; **names** in Voucherify using this method. Data will be updated for each product included in the CSV file whose **source_id** matches a source ID in Voucherify. No other data can be updated other than the product name. &gt; - Note that dates and date-time attributes need to be provided in compliance with the **ISO 8601 norms**. For example, 2022-03-11T09:00:00.000Z or 2022-03-11 &gt;    - &#x60;YYYY-MM-DD&#x60; &gt;    - &#x60;YYYY-MM-DDTHH&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ss&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ss.SSSZ&#x60; &gt; - Columns that cannot be mapped to standard fields, will be mapped to **Custom attributes** and added as **products&#39; metadata**. There is no limit on the number of custom attributes that you can import as metadata.  &gt; - To provide the proper data type, you need to add all custom attributes to the metadata schema **before importing the file**. Read more [here](https://support.voucherify.io/article/99-schema-validation-metadata#add-metadata). &gt; - **Product attributes** (not custom attributes) need to be separated by a comma and enclosed in double quotes, i.e \&quot;attribute1,attribute2\&quot;. &gt; - Headers with metadata names **can&#39;t contain white-space characters**. &gt; - If you import metadata defined in the schema as **arrays (multiple)**, you need to separate each value using a comma, for example:   &gt;    - array of strings: \&quot;subscribed,premium\&quot;   &gt;    - array of numbers: \&quot;123,234\&quot;.  &gt;    - array of dates: \&quot;2000-01-01,2000-01-02\&quot;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @return ProductsImportCsvCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and products will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsImportCsvCreateResponseBody importProductsUsingCsv(File _file) throws ApiException {
        ApiResponse<ProductsImportCsvCreateResponseBody> localVarResp = importProductsUsingCsvWithHttpInfo(_file);
        return localVarResp.getData();
    }

    /**
     * Import Products using CSV
     * Import products into the repository using a CSV file.    Curl Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/products/importCSV \\   -F file&#x3D;@/path/to/products.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60;  The CSV file has to include headers in the first line.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Standard product fields mapping &gt; &gt; - Create a **comma separated value (CSV) file** or download our CSV import template. You can find an example template [here](https://s3.amazonaws.com/helpscout.net/docs/assets/5902f1c12c7d3a057f88a36d/attachments/627b82ed68d51e779443f550/Import_products_template.csv). &gt; - Supported CSV file headers: &#x60;name,source_id,price,attributes,image_url,Metadata_property_name&#x60; &gt; - **Name** is a **required** field. The remaining fields in the CSV template are optional. &gt; - Override/Update products&#39; **names** in Voucherify using this method. Data will be updated for each product included in the CSV file whose **source_id** matches a source ID in Voucherify. No other data can be updated other than the product name. &gt; - Note that dates and date-time attributes need to be provided in compliance with the **ISO 8601 norms**. For example, 2022-03-11T09:00:00.000Z or 2022-03-11 &gt;    - &#x60;YYYY-MM-DD&#x60; &gt;    - &#x60;YYYY-MM-DDTHH&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ss&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ss.SSSZ&#x60; &gt; - Columns that cannot be mapped to standard fields, will be mapped to **Custom attributes** and added as **products&#39; metadata**. There is no limit on the number of custom attributes that you can import as metadata.  &gt; - To provide the proper data type, you need to add all custom attributes to the metadata schema **before importing the file**. Read more [here](https://support.voucherify.io/article/99-schema-validation-metadata#add-metadata). &gt; - **Product attributes** (not custom attributes) need to be separated by a comma and enclosed in double quotes, i.e \&quot;attribute1,attribute2\&quot;. &gt; - Headers with metadata names **can&#39;t contain white-space characters**. &gt; - If you import metadata defined in the schema as **arrays (multiple)**, you need to separate each value using a comma, for example:   &gt;    - array of strings: \&quot;subscribed,premium\&quot;   &gt;    - array of numbers: \&quot;123,234\&quot;.  &gt;    - array of dates: \&quot;2000-01-01,2000-01-02\&quot;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @return ApiResponse&lt;ProductsImportCsvCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and products will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsImportCsvCreateResponseBody> importProductsUsingCsvWithHttpInfo(File _file) throws ApiException {
        okhttp3.Call localVarCall = importProductsUsingCsvValidateBeforeCall(_file, null);
        Type localVarReturnType = new TypeToken<ProductsImportCsvCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Import Products using CSV (asynchronously)
     * Import products into the repository using a CSV file.    Curl Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/products/importCSV \\   -F file&#x3D;@/path/to/products.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60;  The CSV file has to include headers in the first line.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Standard product fields mapping &gt; &gt; - Create a **comma separated value (CSV) file** or download our CSV import template. You can find an example template [here](https://s3.amazonaws.com/helpscout.net/docs/assets/5902f1c12c7d3a057f88a36d/attachments/627b82ed68d51e779443f550/Import_products_template.csv). &gt; - Supported CSV file headers: &#x60;name,source_id,price,attributes,image_url,Metadata_property_name&#x60; &gt; - **Name** is a **required** field. The remaining fields in the CSV template are optional. &gt; - Override/Update products&#39; **names** in Voucherify using this method. Data will be updated for each product included in the CSV file whose **source_id** matches a source ID in Voucherify. No other data can be updated other than the product name. &gt; - Note that dates and date-time attributes need to be provided in compliance with the **ISO 8601 norms**. For example, 2022-03-11T09:00:00.000Z or 2022-03-11 &gt;    - &#x60;YYYY-MM-DD&#x60; &gt;    - &#x60;YYYY-MM-DDTHH&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ss&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ssZ&#x60; &gt;    - &#x60;YYYY-MM-DDTHH:mm:ss.SSSZ&#x60; &gt; - Columns that cannot be mapped to standard fields, will be mapped to **Custom attributes** and added as **products&#39; metadata**. There is no limit on the number of custom attributes that you can import as metadata.  &gt; - To provide the proper data type, you need to add all custom attributes to the metadata schema **before importing the file**. Read more [here](https://support.voucherify.io/article/99-schema-validation-metadata#add-metadata). &gt; - **Product attributes** (not custom attributes) need to be separated by a comma and enclosed in double quotes, i.e \&quot;attribute1,attribute2\&quot;. &gt; - Headers with metadata names **can&#39;t contain white-space characters**. &gt; - If you import metadata defined in the schema as **arrays (multiple)**, you need to separate each value using a comma, for example:   &gt;    - array of strings: \&quot;subscribed,premium\&quot;   &gt;    - array of numbers: \&quot;123,234\&quot;.  &gt;    - array of dates: \&quot;2000-01-01,2000-01-02\&quot;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and products will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call importProductsUsingCsvAsync(File _file, final ApiCallback<ProductsImportCsvCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = importProductsUsingCsvValidateBeforeCall(_file, _callback);
        Type localVarReturnType = new TypeToken<ProductsImportCsvCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importSkusUsingCsv
     * @param _file File path. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and SKUs will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call importSkusUsingCsvCall(File _file, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/skus/importCSV";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importSkusUsingCsvValidateBeforeCall(File _file, final ApiCallback _callback) throws ApiException {
        return importSkusUsingCsvCall(_file, _callback);

    }

    /**
     * Import SKUs using CSV
     * Import SKUs into the repository using a CSV file.  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard SKU fields will be added to the metadata object. You can find an example template [here](https://s3.amazonaws.com/helpscout.net/docs/assets/5902f1c12c7d3a057f88a36d/attachments/627b98d08c9b585083488a4c/Import_SKUS_template.csv).   Curl Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/skus/importCSV \\   -F file&#x3D;@/path/to/skus.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; &gt; ðŸš§ Import sequence &gt; &gt; First import products using the [dedicated endpoint](ref:import-products-using-csv), then import SKUs using this endpoint to properly match SKUs to products.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Standard SKU fields mapping &gt; &gt; - **Required** fields are &#x60;source_id&#x60; and &#x60;product_id&#x60;. &gt; - Supported CSV file headers: &#x60;product_id,sku,source_id,price,image_url,attributes&#x60; &gt; - SKU **source_id** must be unique in the entire product catalog, no duplicates are allowed. &gt; - SKU attributes need to be in the form of a stringy-fied json, i.e.&#x60;\&quot;{&#39;color&#39;:&#39;blue&#39;}\&quot;&#x60;. These attributes must be defined in the **product** beforehand so you can import them to the SKU. &gt; - You can use this method to update the following parameters in bulk: **sku** and the sku **price**. &gt; - Columns that cannot be mapped to standard fields will be mapped to Custom attributes and added as product metadata. There is no limit on the number of custom attributes that you can import as metadata.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @return SkusImportCsvCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and SKUs will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public SkusImportCsvCreateResponseBody importSkusUsingCsv(File _file) throws ApiException {
        ApiResponse<SkusImportCsvCreateResponseBody> localVarResp = importSkusUsingCsvWithHttpInfo(_file);
        return localVarResp.getData();
    }

    /**
     * Import SKUs using CSV
     * Import SKUs into the repository using a CSV file.  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard SKU fields will be added to the metadata object. You can find an example template [here](https://s3.amazonaws.com/helpscout.net/docs/assets/5902f1c12c7d3a057f88a36d/attachments/627b98d08c9b585083488a4c/Import_SKUS_template.csv).   Curl Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/skus/importCSV \\   -F file&#x3D;@/path/to/skus.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; &gt; ðŸš§ Import sequence &gt; &gt; First import products using the [dedicated endpoint](ref:import-products-using-csv), then import SKUs using this endpoint to properly match SKUs to products.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Standard SKU fields mapping &gt; &gt; - **Required** fields are &#x60;source_id&#x60; and &#x60;product_id&#x60;. &gt; - Supported CSV file headers: &#x60;product_id,sku,source_id,price,image_url,attributes&#x60; &gt; - SKU **source_id** must be unique in the entire product catalog, no duplicates are allowed. &gt; - SKU attributes need to be in the form of a stringy-fied json, i.e.&#x60;\&quot;{&#39;color&#39;:&#39;blue&#39;}\&quot;&#x60;. These attributes must be defined in the **product** beforehand so you can import them to the SKU. &gt; - You can use this method to update the following parameters in bulk: **sku** and the sku **price**. &gt; - Columns that cannot be mapped to standard fields will be mapped to Custom attributes and added as product metadata. There is no limit on the number of custom attributes that you can import as metadata.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @return ApiResponse&lt;SkusImportCsvCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and SKUs will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SkusImportCsvCreateResponseBody> importSkusUsingCsvWithHttpInfo(File _file) throws ApiException {
        okhttp3.Call localVarCall = importSkusUsingCsvValidateBeforeCall(_file, null);
        Type localVarReturnType = new TypeToken<SkusImportCsvCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Import SKUs using CSV (asynchronously)
     * Import SKUs into the repository using a CSV file.  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard SKU fields will be added to the metadata object. You can find an example template [here](https://s3.amazonaws.com/helpscout.net/docs/assets/5902f1c12c7d3a057f88a36d/attachments/627b98d08c9b585083488a4c/Import_SKUS_template.csv).   Curl Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/skus/importCSV \\   -F file&#x3D;@/path/to/skus.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; &gt; ðŸš§ Import sequence &gt; &gt; First import products using the [dedicated endpoint](ref:import-products-using-csv), then import SKUs using this endpoint to properly match SKUs to products.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Standard SKU fields mapping &gt; &gt; - **Required** fields are &#x60;source_id&#x60; and &#x60;product_id&#x60;. &gt; - Supported CSV file headers: &#x60;product_id,sku,source_id,price,image_url,attributes&#x60; &gt; - SKU **source_id** must be unique in the entire product catalog, no duplicates are allowed. &gt; - SKU attributes need to be in the form of a stringy-fied json, i.e.&#x60;\&quot;{&#39;color&#39;:&#39;blue&#39;}\&quot;&#x60;. These attributes must be defined in the **product** beforehand so you can import them to the SKU. &gt; - You can use this method to update the following parameters in bulk: **sku** and the sku **price**. &gt; - Columns that cannot be mapped to standard fields will be mapped to Custom attributes and added as product metadata. There is no limit on the number of custom attributes that you can import as metadata.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and SKUs will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call importSkusUsingCsvAsync(File _file, final ApiCallback<SkusImportCsvCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = importSkusUsingCsvValidateBeforeCall(_file, _callback);
        Type localVarReturnType = new TypeToken<SkusImportCsvCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listProducts
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with product objects. The products are returned sorted by creation date by default, with the most recent products appearing last, unless you specify another sequence using the &#x60;order&#x60; query parameter. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProductsCall(Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/products";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_date", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_date", endDate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listProductsValidateBeforeCall(Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate, final ApiCallback _callback) throws ApiException {
        return listProductsCall(limit, page, order, startDate, endDate, _callback);

    }

    /**
     * List Products
     * Retrieve a list of products.
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @return ProductsListResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with product objects. The products are returned sorted by creation date by default, with the most recent products appearing last, unless you specify another sequence using the &#x60;order&#x60; query parameter. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsListResponseBody listProducts(Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate) throws ApiException {
        ApiResponse<ProductsListResponseBody> localVarResp = listProductsWithHttpInfo(limit, page, order, startDate, endDate);
        return localVarResp.getData();
    }

    /**
     * List Products
     * Retrieve a list of products.
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @return ApiResponse&lt;ProductsListResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with product objects. The products are returned sorted by creation date by default, with the most recent products appearing last, unless you specify another sequence using the &#x60;order&#x60; query parameter. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsListResponseBody> listProductsWithHttpInfo(Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate) throws ApiException {
        okhttp3.Call localVarCall = listProductsValidateBeforeCall(limit, page, order, startDate, endDate, null);
        Type localVarReturnType = new TypeToken<ProductsListResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Products (asynchronously)
     * Retrieve a list of products.
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with product objects. The products are returned sorted by creation date by default, with the most recent products appearing last, unless you specify another sequence using the &#x60;order&#x60; query parameter. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProductsAsync(Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate, final ApiCallback<ProductsListResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = listProductsValidateBeforeCall(limit, page, order, startDate, endDate, _callback);
        Type localVarReturnType = new TypeToken<ProductsListResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listSkusInProduct
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary of SKUs. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listSkusInProductCall(String productId, Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}/skus"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (startDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("start_date", startDate));
        }

        if (endDate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("end_date", endDate));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSkusInProductValidateBeforeCall(String productId, Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling listSkusInProduct(Async)");
        }

        return listSkusInProductCall(productId, limit, page, order, startDate, endDate, _callback);

    }

    /**
     * List SKUs in Product
     * Retrieve all SKUs for a given product.
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @return ProductsSkusListResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary of SKUs. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsSkusListResponseBody listSkusInProduct(String productId, Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate) throws ApiException {
        ApiResponse<ProductsSkusListResponseBody> localVarResp = listSkusInProductWithHttpInfo(productId, limit, page, order, startDate, endDate);
        return localVarResp.getData();
    }

    /**
     * List SKUs in Product
     * Retrieve all SKUs for a given product.
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @return ApiResponse&lt;ProductsSkusListResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary of SKUs. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsSkusListResponseBody> listSkusInProductWithHttpInfo(String productId, Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate) throws ApiException {
        okhttp3.Call localVarCall = listSkusInProductValidateBeforeCall(productId, limit, page, order, startDate, endDate, null);
        Type localVarReturnType = new TypeToken<ProductsSkusListResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List SKUs in Product (asynchronously)
     * Retrieve all SKUs for a given product.
     * @param productId A Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param order Sorts the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param endDate Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary of SKUs. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listSkusInProductAsync(String productId, Integer limit, Integer page, ParameterOrder order, OffsetDateTime startDate, OffsetDateTime endDate, final ApiCallback<ProductsSkusListResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = listSkusInProductValidateBeforeCall(productId, limit, page, order, startDate, endDate, _callback);
        Type localVarReturnType = new TypeToken<ProductsSkusListResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateProduct
     * @param productId A Voucherify product ID or source ID. (required)
     * @param productsUpdateRequestBody Specify the parameters of the product that are to be updated. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns an updated product object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateProductCall(String productId, ProductsUpdateRequestBody productsUpdateRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = productsUpdateRequestBody;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateProductValidateBeforeCall(String productId, ProductsUpdateRequestBody productsUpdateRequestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling updateProduct(Async)");
        }

        return updateProductCall(productId, productsUpdateRequestBody, _callback);

    }

    /**
     * Update Product
     * Updates the specified product by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
     * @param productId A Voucherify product ID or source ID. (required)
     * @param productsUpdateRequestBody Specify the parameters of the product that are to be updated. (optional)
     * @return ProductsUpdateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns an updated product object. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsUpdateResponseBody updateProduct(String productId, ProductsUpdateRequestBody productsUpdateRequestBody) throws ApiException {
        ApiResponse<ProductsUpdateResponseBody> localVarResp = updateProductWithHttpInfo(productId, productsUpdateRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update Product
     * Updates the specified product by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
     * @param productId A Voucherify product ID or source ID. (required)
     * @param productsUpdateRequestBody Specify the parameters of the product that are to be updated. (optional)
     * @return ApiResponse&lt;ProductsUpdateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns an updated product object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsUpdateResponseBody> updateProductWithHttpInfo(String productId, ProductsUpdateRequestBody productsUpdateRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateProductValidateBeforeCall(productId, productsUpdateRequestBody, null);
        Type localVarReturnType = new TypeToken<ProductsUpdateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Product (asynchronously)
     * Updates the specified product by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
     * @param productId A Voucherify product ID or source ID. (required)
     * @param productsUpdateRequestBody Specify the parameters of the product that are to be updated. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns an updated product object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateProductAsync(String productId, ProductsUpdateRequestBody productsUpdateRequestBody, final ApiCallback<ProductsUpdateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateProductValidateBeforeCall(productId, productsUpdateRequestBody, _callback);
        Type localVarReturnType = new TypeToken<ProductsUpdateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateProductsInBulk
     * @param productsUpdateInBulkRequestBody Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateProductsInBulkCall(List<ProductsUpdateInBulkRequestBody> productsUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = productsUpdateInBulkRequestBody;

        // create path and map variables
        String localVarPath = "/v1/products/bulk/async";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateProductsInBulkValidateBeforeCall(List<ProductsUpdateInBulkRequestBody> productsUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        return updateProductsInBulkCall(productsUpdateInBulkRequestBody, _callback);

    }

    /**
     * Update Products in bulk
     * Update several products in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier. If a requested product object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param productsUpdateInBulkRequestBody Create an array of product objects, each with the parameters which you want to update. (optional)
     * @return ProductsUpdateInBulkResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsUpdateInBulkResponseBody updateProductsInBulk(List<ProductsUpdateInBulkRequestBody> productsUpdateInBulkRequestBody) throws ApiException {
        ApiResponse<ProductsUpdateInBulkResponseBody> localVarResp = updateProductsInBulkWithHttpInfo(productsUpdateInBulkRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update Products in bulk
     * Update several products in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier. If a requested product object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param productsUpdateInBulkRequestBody Create an array of product objects, each with the parameters which you want to update. (optional)
     * @return ApiResponse&lt;ProductsUpdateInBulkResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsUpdateInBulkResponseBody> updateProductsInBulkWithHttpInfo(List<ProductsUpdateInBulkRequestBody> productsUpdateInBulkRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateProductsInBulkValidateBeforeCall(productsUpdateInBulkRequestBody, null);
        Type localVarReturnType = new TypeToken<ProductsUpdateInBulkResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Products in bulk (asynchronously)
     * Update several products in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier. If a requested product object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param productsUpdateInBulkRequestBody Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateProductsInBulkAsync(List<ProductsUpdateInBulkRequestBody> productsUpdateInBulkRequestBody, final ApiCallback<ProductsUpdateInBulkResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateProductsInBulkValidateBeforeCall(productsUpdateInBulkRequestBody, _callback);
        Type localVarReturnType = new TypeToken<ProductsUpdateInBulkResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateProductsMetadataInBulk
     * @param productsMetadataUpdateInBulkRequestBody Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateProductsMetadataInBulkCall(ProductsMetadataUpdateInBulkRequestBody productsMetadataUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = productsMetadataUpdateInBulkRequestBody;

        // create path and map variables
        String localVarPath = "/v1/products/metadata/async";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateProductsMetadataInBulkValidateBeforeCall(ProductsMetadataUpdateInBulkRequestBody productsMetadataUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        return updateProductsMetadataInBulkCall(productsMetadataUpdateInBulkRequestBody, _callback);

    }

    /**
     * Update Products&#39; Metadata in bulk
     * Update several product metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier. If a requested product object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param productsMetadataUpdateInBulkRequestBody Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @return ProductsMetadataUpdateInBulkResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsMetadataUpdateInBulkResponseBody updateProductsMetadataInBulk(ProductsMetadataUpdateInBulkRequestBody productsMetadataUpdateInBulkRequestBody) throws ApiException {
        ApiResponse<ProductsMetadataUpdateInBulkResponseBody> localVarResp = updateProductsMetadataInBulkWithHttpInfo(productsMetadataUpdateInBulkRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update Products&#39; Metadata in bulk
     * Update several product metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier. If a requested product object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param productsMetadataUpdateInBulkRequestBody Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @return ApiResponse&lt;ProductsMetadataUpdateInBulkResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsMetadataUpdateInBulkResponseBody> updateProductsMetadataInBulkWithHttpInfo(ProductsMetadataUpdateInBulkRequestBody productsMetadataUpdateInBulkRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateProductsMetadataInBulkValidateBeforeCall(productsMetadataUpdateInBulkRequestBody, null);
        Type localVarReturnType = new TypeToken<ProductsMetadataUpdateInBulkResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Products&#39; Metadata in bulk (asynchronously)
     * Update several product metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier. If a requested product object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param productsMetadataUpdateInBulkRequestBody Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and updates will be added to the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateProductsMetadataInBulkAsync(ProductsMetadataUpdateInBulkRequestBody productsMetadataUpdateInBulkRequestBody, final ApiCallback<ProductsMetadataUpdateInBulkResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateProductsMetadataInBulkValidateBeforeCall(productsMetadataUpdateInBulkRequestBody, _callback);
        Type localVarReturnType = new TypeToken<ProductsMetadataUpdateInBulkResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSku
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param productsSkusUpdateRequestBody Specify the parameters to be updated. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the SKU object with the updated parameters. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSkuCall(String productId, String skuId, ProductsSkusUpdateRequestBody productsSkusUpdateRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = productsSkusUpdateRequestBody;

        // create path and map variables
        String localVarPath = "/v1/products/{productId}/skus/{skuId}"
            .replace("{" + "productId" + "}", localVarApiClient.escapeString(productId.toString()))
            .replace("{" + "skuId" + "}", localVarApiClient.escapeString(skuId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSkuValidateBeforeCall(String productId, String skuId, ProductsSkusUpdateRequestBody productsSkusUpdateRequestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'productId' is set
        if (productId == null) {
            throw new ApiException("Missing the required parameter 'productId' when calling updateSku(Async)");
        }

        // verify the required parameter 'skuId' is set
        if (skuId == null) {
            throw new ApiException("Missing the required parameter 'skuId' when calling updateSku(Async)");
        }

        return updateSkuCall(productId, skuId, productsSkusUpdateRequestBody, _callback);

    }

    /**
     * Update SKU
     * Updates the specified SKU by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.  Fields other than the ones listed in the request body schema won&#39;t be modified. Even if provided, they will be silently skipped.
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param productsSkusUpdateRequestBody Specify the parameters to be updated. (optional)
     * @return ProductsSkusUpdateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the SKU object with the updated parameters. </td><td>  -  </td></tr>
     </table>
     */
    public ProductsSkusUpdateResponseBody updateSku(String productId, String skuId, ProductsSkusUpdateRequestBody productsSkusUpdateRequestBody) throws ApiException {
        ApiResponse<ProductsSkusUpdateResponseBody> localVarResp = updateSkuWithHttpInfo(productId, skuId, productsSkusUpdateRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update SKU
     * Updates the specified SKU by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.  Fields other than the ones listed in the request body schema won&#39;t be modified. Even if provided, they will be silently skipped.
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param productsSkusUpdateRequestBody Specify the parameters to be updated. (optional)
     * @return ApiResponse&lt;ProductsSkusUpdateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the SKU object with the updated parameters. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductsSkusUpdateResponseBody> updateSkuWithHttpInfo(String productId, String skuId, ProductsSkusUpdateRequestBody productsSkusUpdateRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateSkuValidateBeforeCall(productId, skuId, productsSkusUpdateRequestBody, null);
        Type localVarReturnType = new TypeToken<ProductsSkusUpdateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update SKU (asynchronously)
     * Updates the specified SKU by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.  Fields other than the ones listed in the request body schema won&#39;t be modified. Even if provided, they will be silently skipped.
     * @param productId A unique Voucherify &lt;!-- [product](OpenAPI.json/components/schemas/Product) --&gt;[product](ref:get-product) ID or product source ID. (required)
     * @param skuId A Voucherify &lt;!-- [SKU](OpenAPI.json/components/schemas/Sku) --&gt;[SKU ID](ref:get-sku) or SKU source ID. (required)
     * @param productsSkusUpdateRequestBody Specify the parameters to be updated. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns the SKU object with the updated parameters. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSkuAsync(String productId, String skuId, ProductsSkusUpdateRequestBody productsSkusUpdateRequestBody, final ApiCallback<ProductsSkusUpdateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSkuValidateBeforeCall(productId, skuId, productsSkusUpdateRequestBody, _callback);
        Type localVarReturnType = new TypeToken<ProductsSkusUpdateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
