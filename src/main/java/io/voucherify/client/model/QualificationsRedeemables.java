/*
 * Voucherify API
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.voucherify.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.voucherify.client.model.QualificationsRedeemable;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonNull;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.voucherify.client.JSON;

/**
 * List of redeemables for examine qualification.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")

public class QualificationsRedeemables {
  /**
   * The type of the object represented by JSON. Default is &#x60;list&#x60;.
   */
  @JsonAdapter(ObjectEnum.Adapter.class)
  public enum ObjectEnum {
    LIST("list");

    private String value;

    ObjectEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ObjectEnum fromValue(String value) {
      for (ObjectEnum b : ObjectEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
        return null;
    }

    public static class Adapter extends TypeAdapter<ObjectEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ObjectEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ObjectEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ObjectEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_OBJECT = "object";
  @SerializedName(SERIALIZED_NAME_OBJECT)
  private ObjectEnum _object = ObjectEnum.LIST;
    private boolean _objectIsSet = false;

  /**
   * Identifies the name of the attribute that contains the array of qualified redeemables.
   */
  @JsonAdapter(DataRefEnum.Adapter.class)
  public enum DataRefEnum {
    DATA("data");

    private String value;

    DataRefEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataRefEnum fromValue(String value) {
      for (DataRefEnum b : DataRefEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
        return null;
    }

    public static class Adapter extends TypeAdapter<DataRefEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataRefEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataRefEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataRefEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_DATA_REF = "data_ref";
  @SerializedName(SERIALIZED_NAME_DATA_REF)
  private DataRefEnum dataRef = DataRefEnum.DATA;
    private boolean dataRefIsSet = false;

  public static final String SERIALIZED_NAME_DATA = "data";
  @SerializedName(SERIALIZED_NAME_DATA)
  private List<QualificationsRedeemable> data;
    private boolean dataIsSet = false;

  public static final String SERIALIZED_NAME_TOTAL = "total";
  @SerializedName(SERIALIZED_NAME_TOTAL)
  private Integer total;
    private boolean totalIsSet = false;

  public static final String SERIALIZED_NAME_HAS_MORE = "has_more";
  @SerializedName(SERIALIZED_NAME_HAS_MORE)
  private Boolean hasMore;
    private boolean hasMoreIsSet = false;

  public static final String SERIALIZED_NAME_MORE_STARTING_AFTER = "more_starting_after";
  @SerializedName(SERIALIZED_NAME_MORE_STARTING_AFTER)
  private OffsetDateTime moreStartingAfter;
    private boolean moreStartingAfterIsSet = false;

  public QualificationsRedeemables() {
  }

  public QualificationsRedeemables _object(ObjectEnum _object) {
    
    this._object = _object;
    return this;
  }

   /**
   * The type of the object represented by JSON. Default is &#x60;list&#x60;.
   * @return _object
  **/
  @javax.annotation.Nullable
  public ObjectEnum getObject() {
    return _object;
  }


  public void setObject(ObjectEnum _object) {
    this._object = _object;
    this._objectIsSet = true;
  }
  public boolean isObjectSet() {
    return _objectIsSet;
  }


  public QualificationsRedeemables dataRef(DataRefEnum dataRef) {
    
    this.dataRef = dataRef;
    return this;
  }

   /**
   * Identifies the name of the attribute that contains the array of qualified redeemables.
   * @return dataRef
  **/
  @javax.annotation.Nullable
  public DataRefEnum getDataRef() {
    return dataRef;
  }


  public void setDataRef(DataRefEnum dataRef) {
    this.dataRef = dataRef;
    this.dataRefIsSet = true;
  }
  public boolean isDataRefSet() {
    return dataRefIsSet;
  }


  public QualificationsRedeemables data(List<QualificationsRedeemable> data) {
    
    this.data = data;
    return this;
  }

  public QualificationsRedeemables addDataItem(QualificationsRedeemable dataItem) {
    if (this.data == null) {
      this.data = new ArrayList<>();
    }
    this.data.add(dataItem);
    return this;
  }

   /**
   * Array of qualified redeemables.
   * @return data
  **/
  @javax.annotation.Nullable
  public List<QualificationsRedeemable> getData() {
    return data;
  }


  public void setData(List<QualificationsRedeemable> data) {
    this.data = data;
    this.dataIsSet = true;
  }
  public boolean isDataSet() {
    return dataIsSet;
  }


  public QualificationsRedeemables total(Integer total) {
    
    this.total = total;
    return this;
  }

   /**
   * The number of redeemables returned in the API request.
   * @return total
  **/
  @javax.annotation.Nullable
  public Integer getTotal() {
    return total;
  }


  public void setTotal(Integer total) {
    this.total = total;
    this.totalIsSet = true;
  }
  public boolean isTotalSet() {
    return totalIsSet;
  }


  public QualificationsRedeemables hasMore(Boolean hasMore) {
    
    this.hasMore = hasMore;
    return this;
  }

   /**
   * As results are always limited, the &#x60;has_more&#x60; flag indicates if there are more records for given parameters. This lets you know if you can run another request (with different options) to get more records returned in the results.
   * @return hasMore
  **/
  @javax.annotation.Nullable
  public Boolean getHasMore() {
    return hasMore;
  }


  public void setHasMore(Boolean hasMore) {
    this.hasMore = hasMore;
    this.hasMoreIsSet = true;
  }
  public boolean isHasMoreSet() {
    return hasMoreIsSet;
  }


  public QualificationsRedeemables moreStartingAfter(OffsetDateTime moreStartingAfter) {
    
    this.moreStartingAfter = moreStartingAfter;
    return this;
  }

   /**
   * Timestamp representing the date and time to use in &#x60;starting_after&#x60; cursor to get more redeemables.
   * @return moreStartingAfter
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getMoreStartingAfter() {
    return moreStartingAfter;
  }


  public void setMoreStartingAfter(OffsetDateTime moreStartingAfter) {
    this.moreStartingAfter = moreStartingAfter;
    this.moreStartingAfterIsSet = true;
  }
  public boolean isMoreStartingAfterSet() {
    return moreStartingAfterIsSet;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    QualificationsRedeemables qualificationsRedeemables = (QualificationsRedeemables) o;
    return Objects.equals(this._object, qualificationsRedeemables._object) &&
        Objects.equals(this.dataRef, qualificationsRedeemables.dataRef) &&
        Objects.equals(this.data, qualificationsRedeemables.data) &&
        Objects.equals(this.total, qualificationsRedeemables.total) &&
        Objects.equals(this.hasMore, qualificationsRedeemables.hasMore) &&
        Objects.equals(this.moreStartingAfter, qualificationsRedeemables.moreStartingAfter);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(_object, dataRef, data, total, hasMore, moreStartingAfter);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class QualificationsRedeemables {\n");
    sb.append("    _object: ").append(toIndentedString(_object)).append("\n");
    sb.append("    dataRef: ").append(toIndentedString(dataRef)).append("\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    total: ").append(toIndentedString(total)).append("\n");
    sb.append("    hasMore: ").append(toIndentedString(hasMore)).append("\n");
    sb.append("    moreStartingAfter: ").append(toIndentedString(moreStartingAfter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("object");
    openapiFields.add("data_ref");
    openapiFields.add("data");
    openapiFields.add("total");
    openapiFields.add("has_more");
    openapiFields.add("more_starting_after");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!QualificationsRedeemables.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'QualificationsRedeemables' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<QualificationsRedeemables> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(QualificationsRedeemables.class));

       return (TypeAdapter<T>) new TypeAdapter<QualificationsRedeemables>() {
           @Override
           public void write(JsonWriter out, QualificationsRedeemables value) throws IOException {
            JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();

            // 1. Strip all nulls and internal "isSet" markers
            obj.entrySet().removeIf(entry -> entry.getValue().isJsonNull() || entry.getKey().endsWith("IsSet"));

            // 2. Add back explicitly set nulls using reflection
            for (Field field : QualificationsRedeemables.class.getDeclaredFields()) {
              String fieldName = field.getName();
              if (fieldName.endsWith("IsSet")) continue;
              try {
                Field isSetField = QualificationsRedeemables.class.getDeclaredField(fieldName + "IsSet");
                isSetField.setAccessible(true);
                boolean isSet = (boolean) isSetField.get(value);

                field.setAccessible(true);
                Object fieldValue = field.get(value);

                if (isSet && fieldValue == null) {
                  // convert camelCase to snake_case (OpenAPI property names are snake_case)
                  String jsonName = fieldName.replaceAll("([a-z])([A-Z]+)", "$1_$2").toLowerCase();
                  obj.add(jsonName, JsonNull.INSTANCE);
                }
              } catch (NoSuchFieldException ignored) {
                // no isSet marker â†’ skip
              } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
              }
            }

             elementAdapter.write(out, obj);
           }

           @Override
           public QualificationsRedeemables read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of QualificationsRedeemables given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of QualificationsRedeemables
  * @throws IOException if the JSON string is invalid with respect to QualificationsRedeemables
  */
  public static QualificationsRedeemables fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, QualificationsRedeemables.class);
  }

 /**
  * Convert an instance of QualificationsRedeemables to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

